declare module 'dojo-compose/aspect' {
	export interface AdvisingFunction extends Function {
	    next: AdvisingFunction;
	    previous: AdvisingFunction;
	}
	export interface DispatchAdvice<T> {
	    before?: BeforeAdvice[];
	    after?: AfterAdvice<T>[];
	    joinPoint: Function;
	}
	export interface BeforeAdvice {
	    (...args: any[]): any[] | void;
	}
	export interface AfterAdvice<T> {
	    (result: T, ...args: any[]): T;
	}
	export interface AroundAdvice<T> {
	    (origFn: GenericFunction<T>): (...args: any[]) => T;
	}
	export enum AdviceType {
	    Before = 0,
	    After = 1,
	    Around = 2,
	}
	export interface GenericFunction<T> {
	    (...args: any[]): T;
	}
	export function before<T>(joinPoint: GenericFunction<T>, advice: BeforeAdvice): GenericFunction<T>;
	export function after<T>(joinPoint: GenericFunction<T>, advice: AfterAdvice<T>): GenericFunction<T>;
	export function around<T>(joinPoint: GenericFunction<T>, advice: AroundAdvice<T>): GenericFunction<T>;

}
declare module 'dojo-compose/compose' {
	import { BeforeAdvice, AfterAdvice, AroundAdvice } from 'dojo-compose/aspect';
	/**
	 * A custom type guard that determines if the value is a ComposeFactory
	 * @param   value The target to check
	 * @returns       Return true if it is a ComposeFactory, otherwise false
	 */
	export function isComposeFactory(value: any): value is ComposeFactory<any, any>;
	/**
	 * Used to adapt any consructor functions or classes to a compose factory
	 */
	export interface GenericClass<T> {
	    new (...args: any[]): T;
	    prototype: T;
	}
	/**
	 * A callback function use to initialize a new created instance
	 * @param instance The newly constructed instance
	 * @param options Any options that were passed to the factory
	 * @template T The type of the instance
	 * @template O The type of the options being passed
	 */
	export interface ComposeInitializationFunction<T, O> {
	    (instance: T, options?: O): void;
	}
	export interface ComposeFactory<T, O> {
	    /**
	     * Extend the factory prototype with the supplied object literal, class, or factory
	     * @param extension The object literal, class or factory to extend
	     * @template T The original type of the factory
	     * @template U The type of the extension
	     * @template O The type of the factory options
	     * @template P The type of the extension factory options
	     */
	    extend<U>(extension: U | GenericClass<U>): ComposeFactory<T & U, O>;
	    extend<U, P>(extension: ComposeFactory<U, P>): ComposeFactory<T & U, O & P>;
	}
	export interface Compose {
	    /**
	     * Extend a compose factory prototype with the supplied object literal, class, or
	     * factory.
	     * @param base The base compose factory to extend
	     * @param extension The object literal, class or factory that is the extension
	     * @template T The base type of the factory
	     * @template U The type of the extension
	     * @template O The type of the base factory options
	     * @template P The type of the extension factory options
	     */
	    extend<T, O, U>(base: ComposeFactory<T, O>, extension: U | GenericClass<U>): ComposeFactory<T & U, O>;
	    extend<T, O, U, P>(base: ComposeFactory<T, O>, extension: ComposeFactory<U, P>): ComposeFactory<T & U, O & P>;
	}
	export interface OverlayFunction<T> {
	    (proto: T): void;
	}
	export interface ComposeFactory<T, O> {
	    overlay(overlayFunction: OverlayFunction<T>): ComposeFactory<T, O>;
	}
	export interface Compose {
	    overlay<T, O>(base: ComposeFactory<T, O>, overlayFunction: OverlayFunction<T>): ComposeFactory<T, O>;
	}
	export interface AspectAdvice {
	    before?: {
	        [method: string]: BeforeAdvice;
	    };
	    after?: {
	        [method: string]: AfterAdvice<any>;
	    };
	    around?: {
	        [method: string]: AroundAdvice<any>;
	    };
	}
	/**
	 * Either a class, object literal, or a factory
	 */
	export type ComposeMixinItem<T, O> = GenericClass<T> | T | ComposeFactory<T, O>;
	export interface ComposeMixinDescriptor<T, O, U, P> {
	    /**
	     * The class, object literal, or factory to be mixed in
	     */
	    mixin?: ComposeMixinItem<U, P>;
	    /**
	     * An initialize function to be executed upon construction
	     */
	    initialize?: ComposeInitializationFunction<T & U, O & P>;
	    /**
	     * Aspect Oriented Advice to be mixed into the factory
	     */
	    aspectAdvice?: AspectAdvice;
	}
	/**
	 * Identifies a compose factory or other object that can be
	 * transformed into a ComposeMixinDescriptor
	 */
	export interface ComposeMixinable<U, P> {
	    factoryDescriptor<T, O>(): ComposeMixinDescriptor<T, O, U, P>;
	}
	export interface ComposeFactory<T, O> extends ComposeMixinable<T, O> {
	    /**
	     * Mixin additional mixins, initialization logic, and aspect advice into the factory
	     * @param mixin An object literal that describes what to mixin
	     */
	    mixin<U, P>(mixin: ComposeMixinable<U, P>): ComposeFactory<T & U, O & P>;
	    mixin<U, P>(mixin: ComposeMixinDescriptor<T, O, U, P>): ComposeFactory<T & U, O & P>;
	}
	export interface Compose {
	    /**
	     * Mixin additional mixins, initialization logic, and aspect advice into a factory
	     * @param base The base factory that is the target of the mixin
	     * @param mixin An object literal that describes what to mixin
	     */
	    mixin<T, O, U, P>(base: ComposeFactory<T, O>, mixin: ComposeMixinable<U, P>): ComposeFactory<T & U, O & P>;
	    mixin<T, O, U, P>(base: ComposeFactory<T, O>, mixin: ComposeMixinDescriptor<T, O, U, P>): ComposeFactory<T & U, O & P>;
	}
	export interface GenericFunction<T> {
	    (...args: any[]): T;
	}
	export interface ComposeFactory<T, O> {
	    from(base: GenericClass<any>, method: string): ComposeFactory<T, O>;
	    from(base: ComposeFactory<any, any>, method: string): ComposeFactory<T, O>;
	    before(method: string, advice: BeforeAdvice): ComposeFactory<T, O>;
	    after<P>(method: string, advice: AfterAdvice<P>): ComposeFactory<T, O>;
	    around<P>(method: string, advice: AroundAdvice<P>): ComposeFactory<T, O>;
	    aspect(advice: AspectAdvice): ComposeFactory<T, O>;
	}
	export interface Compose {
	    from<T extends Function>(base: GenericClass<any>, method: string): T;
	    from<T extends Function>(base: ComposeFactory<any, any>, method: string): T;
	    before<T>(base: GenericClass<any>, method: string, advice: BeforeAdvice): GenericFunction<T>;
	    before<T>(base: ComposeFactory<any, any>, method: string, advice: BeforeAdvice): GenericFunction<T>;
	    before<T>(method: GenericFunction<T>, advice: BeforeAdvice): GenericFunction<T>;
	    after<T>(base: GenericClass<any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;
	    after<T>(base: ComposeFactory<any, any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;
	    after<T>(method: GenericFunction<T>, advice: AfterAdvice<T>): GenericFunction<T>;
	    around<T>(base: GenericClass<any>, method: string, advice: AroundAdvice<T>): GenericFunction<T>;
	    around<T>(base: ComposeFactory<any, any>, method: string, advice: AroundAdvice<T>): GenericFunction<T>;
	    around<T>(method: GenericFunction<T>, advice: AroundAdvice<T>): GenericFunction<T>;
	    aspect<O, A>(base: ComposeFactory<O, A>, advice: AspectAdvice): ComposeFactory<O, A>;
	}
	export interface ComposeFactory<T, O> {
	    (options?: O): T;
	    prototype: T;
	}
	export interface Compose {
	    <T, O>(base: GenericClass<T>, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;
	    <T, O, P>(base: ComposeFactory<T, O>, initFunction?: ComposeInitializationFunction<T, P>): ComposeFactory<T, O & P>;
	    <T, O>(base: T, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;
	    create<T, O>(base: GenericClass<T>, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;
	    create<T, O, P>(base: ComposeFactory<T, O>, initFunction?: ComposeInitializationFunction<T, P>): ComposeFactory<T, O & P>;
	    create<T, O>(base: T, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;
	}
	export interface ComposeFactory<T, O> {
	    static<S>(staticProperties: S): ComposeFactory<T, O> & S;
	}
	export interface Compose {
	    static<F extends ComposeFactory<T, O>, T, O, S>(factory: F, staticProperties: S): F & S;
	} const compose: Compose;
	export default compose;

}
