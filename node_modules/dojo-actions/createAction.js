(function (factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(["require", "exports", 'dojo-compose/compose', 'dojo-core/Map', 'dojo-core/Promise', 'dojo-core/WeakMap', 'dojo-core/lang'], factory);
    }
})(function (require, exports) {
    "use strict";
    /**
     * The actions module for Dojo 2
     * @module dojo-actions/actions
     */
    var compose_1 = require('dojo-compose/compose');
    var Map_1 = require('dojo-core/Map');
    var Promise_1 = require('dojo-core/Promise');
    var WeakMap_1 = require('dojo-core/WeakMap');
    var lang_1 = require('dojo-core/lang');
    /* Cannot use an indexer, because indexers can only be string | number */
    var actionMap = new Map_1.default();
    var actionMethods = new WeakMap_1.default();
    /**
     * Decorate a Thenable/Promise to be an ActionPromise
     * @param    p The target to decorate
     * @returns    The decorated ActionPromise
     * @template T The return type of the action
     * @template O (extends ActionOptions) The options for the action
     */
    function decoratePromise(p, action) {
        var result = p;
        result.undo = function undo() {
            return decoratePromise(p.then(function () { return undoFn.call(action); }), action);
        };
        result.redo = function redo(options) {
            return decoratePromise(p.then(function () { return redoFn.call(action, options); }), action);
        };
        return result;
    }
    function undoFn() {
        var action = this;
        var _undo = actionMethods.get(action).undo;
        /* if undo is not defined, we will resolve with undefined */
        if (!_undo) {
            return new Promise_1.default(function (resolve) { resolve(); });
        }
        if (!action.enabled) {
            return new Promise_1.default(function (resolve, reject) {
                reject(new Error("Action \"" + action.type + "\" not enabled"));
            });
        }
        try {
            var result_1 = _undo.call(action);
            return Promise_1.isThenable(result_1) ? result_1 : new Promise_1.default(function (resolve) {
                resolve(result_1);
            });
        }
        catch (e) {
            return new Promise_1.default(function (resolve, reject) {
                reject(e);
            });
        }
    }
    function redoFn(options) {
        var action = this;
        /* If redo is undefined, we will automatically substitute do */
        var _redo = actionMethods.get(action).redo || actionMethods.get(action).do;
        if (!action.enabled) {
            return new Promise_1.default(function (resolve, reject) {
                reject(new Error("Action \"" + String(action.type) + "\" not enabled"));
            });
        }
        try {
            var result_2 = _redo.call(action, options);
            return Promise_1.isThenable(result_2) ? result_2 : new Promise_1.default(function (resolve) {
                resolve(result_2);
            });
        }
        catch (e) {
            return new Promise_1.default(function (resolve, reject) {
                reject(e);
            });
        }
    }
    function doFn(options) {
        var action = this;
        if (!action.enabled) {
            return decoratePromise(new Promise_1.default(function (resolve, reject) {
                reject(new Error("Action \"" + String(action.type) + "\" not enabled"));
            }), action);
        }
        try {
            var _do = actionMethods.get(action).do;
            var result_3 = _do.call(action, options);
            return decoratePromise(Promise_1.isThenable(result_3) ? result_3 : new Promise_1.default(function (resolve) {
                resolve(result_3);
            }), action);
        }
        catch (e) {
            return decoratePromise(new Promise_1.default(function (resolve, reject) {
                reject(e);
            }), action);
        }
    }
    /**
     * A factory that creates a new action
     */
    var createAction = compose_1.default({
        do: doFn,
        enabled: false,
        disable: function () {
            var _this = this;
            return new Promise_1.default(function (resolve) {
                resolve(_this.enabled = false);
            });
        },
        enable: function () {
            var _this = this;
            return new Promise_1.default(function (resolve) {
                resolve(_this.enabled = true);
            });
        },
        destroy: function () {
            var _this = this;
            return new Promise_1.default(function (resolve) {
                actionMap.delete(_this.type);
                Object.defineProperty(_this, 'type', {
                    value: undefined
                });
                actionMethods.delete(_this);
                delete _this.state;
                _this.enabled = false;
                resolve(false);
            });
        }
    }, function (instance, options) {
        if (!options.type) {
            throw new TypeError('Missing action type, cannot create action.');
        }
        if (!options.do) {
            throw new TypeError('Missing action method "do", cannot create action.');
        }
        if (actionMap.has(options.type)) {
            throw new TypeError("Duplicate action type of \"" + String(options.type) + "\"");
        }
        actionMethods.set(instance, {
            do: options.do,
            undo: options.undo,
            redo: options.redo,
            enabler: options.enabler
        });
        /* Makes the property read only, because we don't want
           accidental reassignment */
        Object.defineProperty(instance, 'type', {
            value: options.type,
            writable: false,
            enumerable: true,
            configurable: true
        });
        instance.state = {};
        if (options.state) {
            lang_1.assign(instance.state, options.state);
        }
        instance.enabled = true;
        actionMap.set(instance.type, instance);
    });
    /**
     * Returns an action based on the supplied label
     * @param    type The type of action to be retrieved
     * @returns       The action (or undefined)
     * @template T    The type that the action's promise will resolve to
     * @template O    (extends ActionOptions) the type of the options to be passed the do or redo function
     * @template S    (extends ActionState) the type of state for the action
     */
    function byType(type) {
        return actionMap.get(type);
    }
    exports.byType = byType;
    ;
    /**
     * Type guard to determine if the value is an Action
     * @param    value The value to be checked
     * @returns        Returns `true` if is an action, otherwise `false`
     */
    function isAction(value) {
        return typeof value === 'object' && 'type' in value && 'do' in value && typeof value.do === 'function';
    }
    exports.isAction = isAction;
    /**
     * Returns if the current action is enabled or not
     * @param   action The action label or an action instance
     * @returns        Returns true if enabled or false if disabled
     * @template T     The type that the action's promise will resolve to
     * @template O     (extends ActionOptions) the type of the options to be passed the do or redo function
     * @template S     (extends ActionState) the type of state for the action
     */
    function isEnabled(action) {
        return isAction(action) ? action.enabled : actionMap.has(action) && actionMap.get(action).enabled;
    }
    exports.isEnabled = isEnabled;
    ;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = createAction;
});
//# sourceMappingURL=_debug/createAction.js.map